"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugin = void 0;
const typedoc_1 = require("typedoc");
const module_category_merger_1 = require("./merger/module_category_merger");
const module_merger_1 = require("./merger/module_merger");
const project_merger_1 = require("./merger/project_merger");
const plugin_options_1 = require("./plugin_options");
const utils_1 = require("./utils");
/**
 * The "Merge Modules" plugin.
 *
 * # What does it do?
 *
 * This plugin merges the content of modules.
 */
class Plugin {
    constructor() {
        /** The options of the plugin. */
        this.options = new plugin_options_1.PluginOptions();
    }
    /**
     * Returns if the plugin is enabled.
     * @returns True if the plugin is enabled, otherwise false.
     */
    get isEnabled() {
        return this.options.mode !== "off";
    }
    /**
     * Initializes the plugin.
     * @param typedoc The TypeDoc application.
     */
    initialize(typedoc) {
        this.options.addToApplication(typedoc);
        this.subscribeToApplicationEvents(typedoc);
    }
    /**
     * Subscribes to events of the application so that the plugin can do its work
     * in the particular doc generation phases.
     * @param typedoc The TypeDoc application.
     */
    subscribeToApplicationEvents(typedoc) {
        typedoc.converter.on(typedoc_1.Converter.EVENT_BEGIN, (c) => this.onConverterBegin(c));
        typedoc.converter.on(typedoc_1.Converter.EVENT_CREATE_DECLARATION, (c, r) => this.onConverterCreateDeclaration(c, r));
        typedoc.converter.on(typedoc_1.Converter.EVENT_RESOLVE_BEGIN, (c) => this.onConverterResolveBegin(c));
    }
    /**
     * Triggered when the converter begins converting a project.
     * @param context Describes the current state the converter is in.
     */
    onConverterBegin(context) {
        this.options.readValuesFromApplication(context.converter.owner);
    }
    /**
     * Triggered when the converter has created a declaration reflection.
     * @param context Describes the current state the converter is in.
     * @param reflection The reflection that has been created.
     */
    onConverterCreateDeclaration(context, reflection) {
        if (this.isEnabled &&
            this.options.renameDefaults &&
            reflection.name === "default" &&
            reflection.kindOf(typedoc_1.ReflectionKind.ClassOrInterface |
                typedoc_1.ReflectionKind.Enum |
                typedoc_1.ReflectionKind.Function |
                typedoc_1.ReflectionKind.ObjectLiteral |
                typedoc_1.ReflectionKind.TypeAlias |
                typedoc_1.ReflectionKind.TypeLiteral |
                typedoc_1.ReflectionKind.Variable)) {
            const originalName = (0, utils_1.tryGetOriginalReflectionName)(context, reflection);
            if (originalName) {
                reflection.name = originalName;
            }
        }
    }
    /**
     * Triggered when the TypeDoc converter begins resolving a project.
     * @param context Describes the current state the converter is in.
     */
    onConverterResolveBegin(context) {
        var _a;
        if (this.isEnabled) {
            (_a = this.createMerger(context.project)) === null || _a === void 0 ? void 0 : _a.execute();
        }
    }
    /**
     * Creates a merger object for the given project.
     * @param project The project on which the merger should operate.
     * @returns The merger object, or undefined if the plugin is turned off.
     */
    createMerger(project) {
        if (this.options.mode === "project") {
            return new project_merger_1.ProjectMerger(project);
        }
        else if (this.options.mode === "module") {
            return new module_merger_1.ModuleMerger(project);
        }
        else if (this.options.mode === "module-category") {
            return new module_category_merger_1.ModuleCategoryMerger(project);
        }
        return undefined;
    }
}
exports.Plugin = Plugin;
